#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

/* automatically generated by rust-bindgen 0.60.1 */

pub const OPENMPT_API_VERSION_MAJOR: u32 = 0;
pub const OPENMPT_API_VERSION_MINOR: u32 = 6;
pub const OPENMPT_API_VERSION_PATCH: u32 = 5;
pub const OPENMPT_API_VERSION_PREREL: &[u8; 1usize] = b"\0";
pub const OPENMPT_API_VERSION_IS_PREREL: u32 = 0;
pub const OPENMPT_STREAM_SEEK_SET: u32 = 0;
pub const OPENMPT_STREAM_SEEK_CUR: u32 = 1;
pub const OPENMPT_STREAM_SEEK_END: u32 = 2;
pub const OPENMPT_ERROR_OK: u32 = 0;
pub const OPENMPT_ERROR_BASE: u32 = 256;
pub const OPENMPT_ERROR_UNKNOWN: u32 = 257;
pub const OPENMPT_ERROR_EXCEPTION: u32 = 267;
pub const OPENMPT_ERROR_OUT_OF_MEMORY: u32 = 277;
pub const OPENMPT_ERROR_RUNTIME: u32 = 286;
pub const OPENMPT_ERROR_RANGE: u32 = 287;
pub const OPENMPT_ERROR_OVERFLOW: u32 = 288;
pub const OPENMPT_ERROR_UNDERFLOW: u32 = 289;
pub const OPENMPT_ERROR_LOGIC: u32 = 296;
pub const OPENMPT_ERROR_DOMAIN: u32 = 297;
pub const OPENMPT_ERROR_LENGTH: u32 = 298;
pub const OPENMPT_ERROR_OUT_OF_RANGE: u32 = 299;
pub const OPENMPT_ERROR_INVALID_ARGUMENT: u32 = 300;
pub const OPENMPT_ERROR_GENERAL: u32 = 357;
pub const OPENMPT_ERROR_INVALID_MODULE_POINTER: u32 = 358;
pub const OPENMPT_ERROR_ARGUMENT_NULL_POINTER: u32 = 359;
pub const OPENMPT_ERROR_FUNC_RESULT_NONE: u32 = 0;
pub const OPENMPT_ERROR_FUNC_RESULT_LOG: u32 = 1;
pub const OPENMPT_ERROR_FUNC_RESULT_STORE: u32 = 2;
pub const OPENMPT_ERROR_FUNC_RESULT_DEFAULT: u32 = 3;
pub const OPENMPT_PROBE_FILE_HEADER_FLAGS_MODULES: u32 = 1;
pub const OPENMPT_PROBE_FILE_HEADER_FLAGS_CONTAINERS: u32 = 2;
pub const OPENMPT_PROBE_FILE_HEADER_FLAGS_DEFAULT: u32 = 3;
pub const OPENMPT_PROBE_FILE_HEADER_FLAGS_NONE: u32 = 0;
pub const OPENMPT_PROBE_FILE_HEADER_RESULT_SUCCESS: u32 = 1;
pub const OPENMPT_PROBE_FILE_HEADER_RESULT_FAILURE: u32 = 0;
pub const OPENMPT_PROBE_FILE_HEADER_RESULT_WANTMOREDATA: i32 = -1;
pub const OPENMPT_PROBE_FILE_HEADER_RESULT_ERROR: i32 = -255;
pub const OPENMPT_MODULE_RENDER_MASTERGAIN_MILLIBEL: u32 = 1;
pub const OPENMPT_MODULE_RENDER_STEREOSEPARATION_PERCENT: u32 = 2;
pub const OPENMPT_MODULE_RENDER_INTERPOLATIONFILTER_LENGTH: u32 = 3;
pub const OPENMPT_MODULE_RENDER_VOLUMERAMPING_STRENGTH: u32 = 4;
pub const OPENMPT_MODULE_COMMAND_NOTE: u32 = 0;
pub const OPENMPT_MODULE_COMMAND_INSTRUMENT: u32 = 1;
pub const OPENMPT_MODULE_COMMAND_VOLUMEEFFECT: u32 = 2;
pub const OPENMPT_MODULE_COMMAND_EFFECT: u32 = 3;
pub const OPENMPT_MODULE_COMMAND_VOLUME: u32 = 4;
pub const OPENMPT_MODULE_COMMAND_PARAMETER: u32 = 5;
pub const LIBOPENMPT_DEPRECATED_STRING_CONSTANT: ::std::os::raw::c_int = 0;
extern "C" {
    #[doc = " \\brief Get the libopenmpt version number"]
    #[doc = ""]
    #[doc = " Returns the libopenmpt version number."]
    #[doc = " \\return The value represents (major << 24 + minor << 16 + patch << 0)."]
    #[doc = " \\remarks libopenmpt < 0.3.0-pre used the following scheme: (major << 24 + minor << 16 + revision)."]
    pub fn openmpt_get_library_version() -> u32;
}
extern "C" {
    #[doc = " \\brief Get the core version number"]
    #[doc = ""]
    #[doc = " Return the OpenMPT core version number."]
    #[doc = " \\return The value represents (majormajor << 24 + major << 16 + minor << 8 + minorminor)."]
    pub fn openmpt_get_core_version() -> u32;
}
extern "C" {
    #[doc = " \\brief Free a string returned by libopenmpt"]
    #[doc = ""]
    #[doc = " Frees any string that got returned by libopenmpt."]
    pub fn openmpt_free_string(str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Get library related metadata."]
    #[doc = ""]
    #[doc = " \\param key Key to query."]
    #[doc = "       Possible keys are:"]
    #[doc = "        -  \"library_version\": verbose library version string"]
    #[doc = "        -  \"library_version_is_release\": \"1\" if the version is an officially released version"]
    #[doc = "        -  \"library_features\": verbose library features string"]
    #[doc = "        -  \"core_version\": verbose OpenMPT core version string"]
    #[doc = "        -  \"source_url\": original source code URL"]
    #[doc = "        -  \"source_date\": original source code date"]
    #[doc = "        -  \"source_revision\": original source code revision"]
    #[doc = "        -  \"source_is_modified\": \"1\" if the original source has been modified"]
    #[doc = "        -  \"source_has_mixed_revisions\": \"1\" if the original source has been compiled from different various revision"]
    #[doc = "        -  \"source_is_package\": \"1\" if the original source has been obtained from a source pacakge instead of source code version control"]
    #[doc = "        -  \"build\": information about the current build (e.g. the build date or compiler used)"]
    #[doc = "        -  \"build_compiler\": information about the compiler used to build libopenmpt"]
    #[doc = "        -  \"credits\": all contributors"]
    #[doc = "        -  \"contact\": contact information about libopenmpt"]
    #[doc = "        -  \"license\": the libopenmpt license"]
    #[doc = "        -  \"url\": libopenmpt website URL"]
    #[doc = "        -  \"support_forum_url\": libopenmpt support and discussions forum URL"]
    #[doc = "        -  \"bugtracker_url\": libopenmpt bug and issue tracker URL"]
    #[doc = " \\return A (possibly multi-line) string containing the queried information. If no information is available, the string is empty."]
    pub fn openmpt_get_string(key: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get a list of supported file extensions"]
    #[doc = ""]
    #[doc = " \\return The semicolon-separated list of extensions supported by this libopenmpt build. The extensions are returned lower-case without a leading dot."]
    pub fn openmpt_get_supported_extensions() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Query whether a file extension is supported"]
    #[doc = ""]
    #[doc = " \\param extension file extension to query without a leading dot. The case is ignored."]
    #[doc = " \\return 1 if the extension is supported by libopenmpt, 0 otherwise."]
    pub fn openmpt_is_extension_supported(
        extension: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Read bytes from stream"]
#[doc = ""]
#[doc = " Read bytes data from stream to dst."]
#[doc = " \\param stream Stream to read data from"]
#[doc = " \\param dst Target where to copy data."]
#[doc = " \\param bytes Number of bytes to read."]
#[doc = " \\return Number of bytes actually read and written to dst."]
#[doc = " \\retval 0 End of stream or error."]
#[doc = " \\remarks Short reads are allowed as long as they return at least 1 byte if EOF is not reached."]
pub type openmpt_stream_read_func = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_void,
        bytes: usize,
    ) -> usize,
>;
#[doc = " \\brief Seek stream position"]
#[doc = ""]
#[doc = " Seek to stream position offset at whence."]
#[doc = " \\param stream Stream to operate on."]
#[doc = " \\param offset Offset to seek to."]
#[doc = " \\param whence OPENMPT_STREAM_SEEK_SET, OPENMPT_STREAM_SEEK_CUR, OPENMPT_STREAM_SEEK_END. See C89 documentation."]
#[doc = " \\return Returns 0 on success."]
#[doc = " \\retval 0 Success."]
#[doc = " \\retval -1 Failure. Position does not get updated."]
#[doc = " \\remarks libopenmpt will not try to seek beyond the file size, thus it is not important whether you allow for virtual positioning after the file end, or return an error in that case. The position equal to the file size needs to be seekable to."]
pub type openmpt_stream_seek_func = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut ::std::os::raw::c_void,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " \\brief Tell stream position"]
#[doc = ""]
#[doc = " Tell position of stream."]
#[doc = " \\param stream Stream to operate on."]
#[doc = " \\return Current position in stream."]
#[doc = " \\retval -1 Failure."]
pub type openmpt_stream_tell_func =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut ::std::os::raw::c_void) -> i64>;
#[doc = " \\brief Stream callbacks"]
#[doc = ""]
#[doc = " Stream callbacks used by libopenmpt for stream operations."]
#[doc = " \\sa openmpt_stream_get_file_callbacks"]
#[doc = " \\sa openmpt_stream_get_fd_callbacks"]
#[doc = " \\sa openmpt_stream_get_buffer_callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openmpt_stream_callbacks {
    #[doc = " \\brief Read callback."]
    #[doc = ""]
    #[doc = " \\sa openmpt_stream_read_func"]
    pub read: openmpt_stream_read_func,
    #[doc = " \\brief Seek callback."]
    #[doc = ""]
    #[doc = " Seek callback can be NULL if seeking is not supported."]
    #[doc = " \\sa openmpt_stream_seek_func"]
    pub seek: openmpt_stream_seek_func,
    #[doc = " \\brief Tell callback."]
    #[doc = ""]
    #[doc = " Tell callback can be NULL if seeking is not supported."]
    #[doc = " \\sa openmpt_stream_tell_func"]
    pub tell: openmpt_stream_tell_func,
}
#[test]
fn bindgen_test_layout_openmpt_stream_callbacks() {
    assert_eq!(
        ::std::mem::size_of::<openmpt_stream_callbacks>(),
        24usize,
        concat!("Size of: ", stringify!(openmpt_stream_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<openmpt_stream_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(openmpt_stream_callbacks))
    );
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<openmpt_stream_callbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(openmpt_stream_callbacks),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<openmpt_stream_callbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(openmpt_stream_callbacks),
                "::",
                stringify!(seek)
            )
        );
    }
    test_field_seek();
    fn test_field_tell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<openmpt_stream_callbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(openmpt_stream_callbacks),
                "::",
                stringify!(tell)
            )
        );
    }
    test_field_tell();
}
#[doc = " \\brief Logging function"]
#[doc = ""]
#[doc = " \\param message UTF-8 encoded log message."]
#[doc = " \\param user User context that was passed to openmpt_module_create2(), openmpt_module_create_from_memory2() or openmpt_could_open_probability2()."]
pub type openmpt_log_func = ::std::option::Option<
    unsafe extern "C" fn(message: *const ::std::os::raw::c_char, user: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " \\brief Default logging function"]
    #[doc = ""]
    #[doc = " Default logging function that logs anything to stderr."]
    pub fn openmpt_log_func_default(
        message: *const ::std::os::raw::c_char,
        user: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Silent logging function"]
    #[doc = ""]
    #[doc = " Silent logging function that throws any log message away."]
    pub fn openmpt_log_func_silent(
        message: *const ::std::os::raw::c_char,
        user: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Check whether the error is transient"]
    #[doc = ""]
    #[doc = " Checks whether an error code represents a transient error which may not occur again in a later try if for example memory has been freed up after an out-of-memory error."]
    #[doc = " \\param error Error code."]
    #[doc = " \\retval 0 Error is not transient."]
    #[doc = " \\retval 1 Error is transient."]
    #[doc = " \\sa OPENMPT_ERROR_OUT_OF_MEMORY"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_is_transient(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Convert error code to text"]
    #[doc = ""]
    #[doc = " Converts an error code into a text string describing the error."]
    #[doc = " \\param error Error code."]
    #[doc = " \\return Allocated string describing the error."]
    #[doc = " \\retval NULL Not enough memory to allocate the string."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_string(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[doc = " \\brief Error function"]
#[doc = ""]
#[doc = " \\param error Error code."]
#[doc = " \\param user User context that was passed to openmpt_module_create2(), openmpt_module_create_from_memory2() or openmpt_could_open_probability2()."]
#[doc = " \\return Mask of OPENMPT_ERROR_FUNC_RESULT_LOG and OPENMPT_ERROR_FUNC_RESULT_STORE."]
#[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_NONE Do not log or store the error."]
#[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_LOG Log the error."]
#[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_STORE Store the error."]
#[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_DEFAULT Log and store the error."]
#[doc = " \\sa OPENMPT_ERROR_FUNC_RESULT_NONE"]
#[doc = " \\sa OPENMPT_ERROR_FUNC_RESULT_LOG"]
#[doc = " \\sa OPENMPT_ERROR_FUNC_RESULT_STORE"]
#[doc = " \\sa OPENMPT_ERROR_FUNC_RESULT_DEFAULT"]
#[doc = " \\sa openmpt_error_func_default"]
#[doc = " \\sa openmpt_error_func_log"]
#[doc = " \\sa openmpt_error_func_store"]
#[doc = " \\sa openmpt_error_func_ignore"]
#[doc = " \\sa openmpt_error_func_errno"]
#[doc = " \\since 0.3.0"]
pub type openmpt_error_func = ::std::option::Option<
    unsafe extern "C" fn(
        error: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " \\brief Default error function"]
    #[doc = ""]
    #[doc = " Causes all errors to be logged and stored."]
    #[doc = " \\param error Error code."]
    #[doc = " \\param user Ignored."]
    #[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_DEFAULT Always."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_func_default(
        error: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Log error function"]
    #[doc = ""]
    #[doc = " Causes all errors to be logged."]
    #[doc = " \\param error Error code."]
    #[doc = " \\param user Ignored."]
    #[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_LOG Always."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_func_log(
        error: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Store error function"]
    #[doc = ""]
    #[doc = " Causes all errors to be stored."]
    #[doc = " \\param error Error code."]
    #[doc = " \\param user Ignored."]
    #[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_STORE Always."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_func_store(
        error: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Ignore error function"]
    #[doc = ""]
    #[doc = " Causes all errors to be neither logged nor stored."]
    #[doc = " \\param error Error code."]
    #[doc = " \\param user Ignored."]
    #[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_NONE Always."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_func_ignore(
        error: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Errno error function"]
    #[doc = ""]
    #[doc = " Causes all errors to be stored in the pointer passed in as user."]
    #[doc = " \\param error Error code."]
    #[doc = " \\param user Pointer to an int as generated by openmpt_error_func_errno_userdata."]
    #[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_NONE user is not NULL."]
    #[doc = " \\retval OPENMPT_ERROR_FUNC_RESULT_DEFAULT user is NULL."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_func_errno(
        error: ::std::os::raw::c_int,
        user: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief User pointer for openmpt_error_func_errno"]
    #[doc = ""]
    #[doc = " Provides a suitable user pointer argument for openmpt_error_func_errno."]
    #[doc = " \\param error Pointer to an integer value to be used as output by openmpt_error_func_errno."]
    #[doc = " \\retval (void*)error."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_error_func_errno_userdata(
        error: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Roughly scan the input stream to find out whether libopenmpt might be able to open it"]
    #[doc = ""]
    #[doc = " \\param stream_callbacks Input stream callback operations."]
    #[doc = " \\param stream Input stream to scan."]
    #[doc = " \\param effort Effort to make when validating stream. Effort 0.0 does not even look at stream at all and effort 1.0 completely loads the file from stream. A lower effort requires less data to be loaded but only gives a rough estimate answer. Use an effort of 0.25 to only verify the header data of the module file."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. May be NULL."]
    #[doc = " \\param user Logging function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\return Probability between 0.0 and 1.0."]
    #[doc = " \\remarks openmpt_could_open_probability() can return any value between 0.0 and 1.0. Only 0.0 and 1.0 are definitive answers, all values in between are just estimates. In general, any return value >0.0 means that you should try loading the file, and any value below 1.0 means that loading may fail. If you want a threshold above which you can be reasonably sure that libopenmpt will be able to load the file, use >=0.5. If you see the need for a threshold below which you could reasonably outright reject a file, use <0.25 (Note: Such a threshold for rejecting on the lower end is not recommended, but may be required for better integration into some other framework's probe scoring.)."]
    #[doc = " \\remarks openmpt_could_open_probability() expects the complete file data to be eventually available to it, even if it is asked to just parse the header. Verification will be unreliable (both false positives and false negatives), if you pretend that the file is just some few bytes of initial data threshold in size. In order to really just access the first bytes of a file, check in your callback functions whether data or seeking is requested beyond your initial data threshold, and in that case, return an error. openmpt_could_open_probability() will treat this as any other I/O error and return 0.0. You must not expect the correct result in this case. You instead must remember that it asked for more data than you currently want to provide to it and treat this situation as if openmpt_could_open_probability() returned 0.5."]
    #[doc = " \\sa \\ref libopenmpt_c_fileio"]
    #[doc = " \\sa openmpt_stream_callbacks"]
    #[doc = " \\deprecated Please use openmpt_could_open_probability2()."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_could_open_probability(
        stream_callbacks: openmpt_stream_callbacks,
        stream: *mut ::std::os::raw::c_void,
        effort: f64,
        logfunc: openmpt_log_func,
        user: *mut ::std::os::raw::c_void,
    ) -> f64;
}
extern "C" {
    #[doc = " \\brief Roughly scan the input stream to find out whether libopenmpt might be able to open it"]
    #[doc = ""]
    #[doc = " \\param stream_callbacks Input stream callback operations."]
    #[doc = " \\param stream Input stream to scan."]
    #[doc = " \\param effort Effort to make when validating stream. Effort 0.0 does not even look at stream at all and effort 1.0 completely loads the file from stream. A lower effort requires less data to be loaded but only gives a rough estimate answer. Use an effort of 0.25 to only verify the header data of the module file."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. May be NULL."]
    #[doc = " \\param user Logging function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\return Probability between 0.0 and 1.0."]
    #[doc = " \\remarks openmpt_could_open_probability() can return any value between 0.0 and 1.0. Only 0.0 and 1.0 are definitive answers, all values in between are just estimates. In general, any return value >0.0 means that you should try loading the file, and any value below 1.0 means that loading may fail. If you want a threshold above which you can be reasonably sure that libopenmpt will be able to load the file, use >=0.5. If you see the need for a threshold below which you could reasonably outright reject a file, use <0.25 (Note: Such a threshold for rejecting on the lower end is not recommended, but may be required for better integration into some other framework's probe scoring.)."]
    #[doc = " \\remarks openmpt_could_open_probability() expects the complete file data to be eventually available to it, even if it is asked to just parse the header. Verification will be unreliable (both false positives and false negatives), if you pretend that the file is just some few bytes of initial data threshold in size. In order to really just access the first bytes of a file, check in your callback functions whether data or seeking is requested beyond your initial data threshold, and in that case, return an error. openmpt_could_open_probability() will treat this as any other I/O error and return 0.0. You must not expect the correct result in this case. You instead must remember that it asked for more data than you currently want to provide to it and treat this situation as if openmpt_could_open_probability() returned 0.5."]
    #[doc = " \\sa \\ref libopenmpt_c_fileio"]
    #[doc = " \\sa openmpt_stream_callbacks"]
    #[doc = " \\deprecated Please use openmpt_could_open_probability2()."]
    pub fn openmpt_could_open_propability(
        stream_callbacks: openmpt_stream_callbacks,
        stream: *mut ::std::os::raw::c_void,
        effort: f64,
        logfunc: openmpt_log_func,
        user: *mut ::std::os::raw::c_void,
    ) -> f64;
}
extern "C" {
    #[doc = " \\brief Roughly scan the input stream to find out whether libopenmpt might be able to open it"]
    #[doc = ""]
    #[doc = " \\param stream_callbacks Input stream callback operations."]
    #[doc = " \\param stream Input stream to scan."]
    #[doc = " \\param effort Effort to make when validating stream. Effort 0.0 does not even look at stream at all and effort 1.0 completely loads the file from stream. A lower effort requires less data to be loaded but only gives a rough estimate answer. Use an effort of 0.25 to only verify the header data of the module file."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. May be NULL."]
    #[doc = " \\param loguser Logging function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param errfunc Error function to define error behaviour. May be NULL."]
    #[doc = " \\param erruser Error function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param error Pointer to an integer where an error may get stored. May be NULL."]
    #[doc = " \\param error_message Pointer to a string pointer where an error message may get stored. May be NULL."]
    #[doc = " \\return Probability between 0.0 and 1.0."]
    #[doc = " \\remarks openmpt_probe_file_header() or openmpt_probe_file_header_without_filesize() provide a simpler and faster interface that fits almost all use cases better. It is recommended to use openmpt_probe_file_header() or openmpt_probe_file_header_without_filesize() instead of openmpt_could_open_probability()."]
    #[doc = " \\remarks openmpt_could_open_probability2() can return any value between 0.0 and 1.0. Only 0.0 and 1.0 are definitive answers, all values in between are just estimates. In general, any return value >0.0 means that you should try loading the file, and any value below 1.0 means that loading may fail. If you want a threshold above which you can be reasonably sure that libopenmpt will be able to load the file, use >=0.5. If you see the need for a threshold below which you could reasonably outright reject a file, use <0.25 (Note: Such a threshold for rejecting on the lower end is not recommended, but may be required for better integration into some other framework's probe scoring.)."]
    #[doc = " \\remarks openmpt_could_open_probability2() expects the complete file data to be eventually available to it, even if it is asked to just parse the header. Verification will be unreliable (both false positives and false negatives), if you pretend that the file is just some few bytes of initial data threshold in size. In order to really just access the first bytes of a file, check in your callback functions whether data or seeking is requested beyond your initial data threshold, and in that case, return an error. openmpt_could_open_probability2() will treat this as any other I/O error and return 0.0. You must not expect the correct result in this case. You instead must remember that it asked for more data than you currently want to provide to it and treat this situation as if openmpt_could_open_probability2() returned 0.5. \\include libopenmpt_example_c_probe.c"]
    #[doc = " \\sa \\ref libopenmpt_c_fileio"]
    #[doc = " \\sa openmpt_stream_callbacks"]
    #[doc = " \\sa openmpt_probe_file_header"]
    #[doc = " \\sa openmpt_probe_file_header_without_filesize"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_could_open_probability2(
        stream_callbacks: openmpt_stream_callbacks,
        stream: *mut ::std::os::raw::c_void,
        effort: f64,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        errfunc: openmpt_error_func,
        erruser: *mut ::std::os::raw::c_void,
        error: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " \\brief Get recommended header size for successfull format probing"]
    #[doc = ""]
    #[doc = " \\sa openmpt_probe_file_header()"]
    #[doc = " \\sa openmpt_probe_file_header_without_filesize()"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_probe_file_header_get_recommended_size() -> usize;
}
extern "C" {
    #[doc = " \\brief Probe the provided bytes from the beginning of a file for supported file format headers to find out whether libopenmpt might be able to open it"]
    #[doc = ""]
    #[doc = " \\param flags Bit mask of OPENMPT_PROBE_FILE_HEADER_FLAGS_MODULES and OPENMPT_PROBE_FILE_HEADER_FLAGS_CONTAINERS, or OPENMPT_PROBE_FILE_HEADER_FLAGS_DEFAULT."]
    #[doc = " \\param data Beginning of the file data."]
    #[doc = " \\param size Size of the beginning of the file data."]
    #[doc = " \\param filesize Full size of the file data on disk."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. May be NULL."]
    #[doc = " \\param loguser Logging function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param errfunc Error function to define error behaviour. May be NULL."]
    #[doc = " \\param erruser Error function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param error Pointer to an integer where an error may get stored. May be NULL."]
    #[doc = " \\param error_message Pointer to a string pointer where an error message may get stored. May be NULL."]
    #[doc = " \\remarks It is recommended to provide openmpt_probe_file_header_get_recommended_size() bytes of data for data and size. If the file is smaller, only provide the filesize amount and set size and filesize to the file's size."]
    #[doc = " \\remarks openmpt_could_open_probability2() provides a more elaborate interface that might be required for special use cases. It is recommended to use openmpt_probe_file_header() though, if possible."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_SUCCESS The file will most likely be supported by libopenmpt."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_FAILURE The file is not supported by libopenmpt."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_WANTMOREDATA An answer could not be determined with the amount of data provided."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_ERROR An internal error occurred."]
    #[doc = " \\sa openmpt_probe_file_header_get_recommended_size()"]
    #[doc = " \\sa openmpt_probe_file_header_without_filesize()"]
    #[doc = " \\sa openmpt_probe_file_header_from_stream()"]
    #[doc = " \\sa openmpt_could_open_probability2()"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_probe_file_header(
        flags: u64,
        data: *const ::std::os::raw::c_void,
        size: usize,
        filesize: u64,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        errfunc: openmpt_error_func,
        erruser: *mut ::std::os::raw::c_void,
        error: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Probe the provided bytes from the beginning of a file for supported file format headers to find out whether libopenmpt might be able to open it"]
    #[doc = ""]
    #[doc = " \\param flags Bit mask of OPENMPT_PROBE_FILE_HEADER_FLAGS_MODULES and OPENMPT_PROBE_FILE_HEADER_FLAGS_CONTAINERS, or OPENMPT_PROBE_FILE_HEADER_FLAGS_DEFAULT."]
    #[doc = " \\param data Beginning of the file data."]
    #[doc = " \\param size Size of the beginning of the file data."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. May be NULL."]
    #[doc = " \\param loguser Logging function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param errfunc Error function to define error behaviour. May be NULL."]
    #[doc = " \\param erruser Error function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param error Pointer to an integer where an error may get stored. May be NULL."]
    #[doc = " \\param error_message Pointer to a string pointer where an error message may get stored. May be NULL."]
    #[doc = " \\remarks It is recommended to use openmpt_probe_file_header() and provide the acutal file's size as a parameter if at all possible. libopenmpt can provide more accurate answers if the filesize is known."]
    #[doc = " \\remarks It is recommended to provide openmpt_probe_file_header_get_recommended_size() bytes of data for data and size. If the file is smaller, only provide the filesize amount and set size to the file's size."]
    #[doc = " \\remarks openmpt_could_open_probability2() provides a more elaborate interface that might be required for special use cases. It is recommended to use openmpt_probe_file_header() though, if possible."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_SUCCESS The file will most likely be supported by libopenmpt."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_FAILURE The file is not supported by libopenmpt."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_WANTMOREDATA An answer could not be determined with the amount of data provided."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_ERROR An internal error occurred."]
    #[doc = " \\sa openmpt_probe_file_header_get_recommended_size()"]
    #[doc = " \\sa openmpt_probe_file_header()"]
    #[doc = " \\sa openmpt_probe_file_header_from_stream()"]
    #[doc = " \\sa openmpt_could_open_probability2()"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_probe_file_header_without_filesize(
        flags: u64,
        data: *const ::std::os::raw::c_void,
        size: usize,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        errfunc: openmpt_error_func,
        erruser: *mut ::std::os::raw::c_void,
        error: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Probe the provided bytes from the beginning of a file for supported file format headers to find out whether libopenmpt might be able to open it"]
    #[doc = ""]
    #[doc = " \\param flags Bit mask of OPENMPT_PROBE_FILE_HEADER_FLAGS_MODULES and OPENMPT_PROBE_FILE_HEADER_FLAGS_CONTAINERS, or OPENMPT_PROBE_FILE_HEADER_FLAGS_DEFAULT."]
    #[doc = " \\param stream_callbacks Input stream callback operations."]
    #[doc = " \\param stream Input stream to scan."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. May be NULL."]
    #[doc = " \\param loguser Logging function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param errfunc Error function to define error behaviour. May be NULL."]
    #[doc = " \\param erruser Error function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param error Pointer to an integer where an error may get stored. May be NULL."]
    #[doc = " \\param error_message Pointer to a string pointer where an error message may get stored. May be NULL."]
    #[doc = " \\remarks The stream is left in an unspecified state when this function returns."]
    #[doc = " \\remarks It is recommended to provide openmpt_probe_file_header_get_recommended_size() bytes of data for data and size. If the file is smaller, only provide the filesize amount and set size and filesize to the file's size."]
    #[doc = " \\remarks openmpt_could_open_probability2() provides a more elaborate interface that might be required for special use cases. It is recommended to use openmpt_probe_file_header() though, if possible."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_SUCCESS The file will most likely be supported by libopenmpt."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_FAILURE The file is not supported by libopenmpt."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_WANTMOREDATA An answer could not be determined with the amount of data provided."]
    #[doc = " \\retval OPENMPT_PROBE_FILE_HEADER_RESULT_ERROR An internal error occurred."]
    #[doc = " \\sa openmpt_probe_file_header_get_recommended_size()"]
    #[doc = " \\sa openmpt_probe_file_header()"]
    #[doc = " \\sa openmpt_probe_file_header_without_filesize()"]
    #[doc = " \\sa openmpt_could_open_probability2()"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_probe_file_header_from_stream(
        flags: u64,
        stream_callbacks: openmpt_stream_callbacks,
        stream: *mut ::std::os::raw::c_void,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        errfunc: openmpt_error_func,
        erruser: *mut ::std::os::raw::c_void,
        error: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openmpt_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openmpt_module_initial_ctl {
    pub ctl: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_openmpt_module_initial_ctl() {
    assert_eq!(
        ::std::mem::size_of::<openmpt_module_initial_ctl>(),
        16usize,
        concat!("Size of: ", stringify!(openmpt_module_initial_ctl))
    );
    assert_eq!(
        ::std::mem::align_of::<openmpt_module_initial_ctl>(),
        8usize,
        concat!("Alignment of ", stringify!(openmpt_module_initial_ctl))
    );
    fn test_field_ctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<openmpt_module_initial_ctl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(openmpt_module_initial_ctl),
                "::",
                stringify!(ctl)
            )
        );
    }
    test_field_ctl();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<openmpt_module_initial_ctl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(openmpt_module_initial_ctl),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
extern "C" {
    #[doc = " \\brief Construct an openmpt_module"]
    #[doc = ""]
    #[doc = " \\param stream_callbacks Input stream callback operations."]
    #[doc = " \\param stream Input stream to load the module from."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. The logging function may be called throughout the lifetime of openmpt_module. May be NULL."]
    #[doc = " \\param loguser User-defined data associated with this module. This value will be passed to the logging callback function (logfunc)"]
    #[doc = " \\param ctls A map of initial ctl values. See openmpt_module_get_ctls()"]
    #[doc = " \\return A pointer to the constructed openmpt_module, or NULL on failure."]
    #[doc = " \\remarks The input data can be discarded after an openmpt_module has been constructed successfully."]
    #[doc = " \\sa openmpt_stream_callbacks"]
    #[doc = " \\sa \\ref libopenmpt_c_fileio"]
    #[doc = " \\deprecated Please use openmpt_module_create2()."]
    pub fn openmpt_module_create(
        stream_callbacks: openmpt_stream_callbacks,
        stream: *mut ::std::os::raw::c_void,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        ctls: *const openmpt_module_initial_ctl,
    ) -> *mut openmpt_module;
}
extern "C" {
    #[doc = " \\brief Construct an openmpt_module"]
    #[doc = ""]
    #[doc = " \\param stream_callbacks Input stream callback operations."]
    #[doc = " \\param stream Input stream to load the module from."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. The logging function may be called throughout the lifetime of openmpt_module. May be NULL."]
    #[doc = " \\param loguser User-defined data associated with this module. This value will be passed to the logging callback function (logfunc)"]
    #[doc = " \\param errfunc Error function to define error behaviour. May be NULL."]
    #[doc = " \\param erruser Error function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param error Pointer to an integer where an error may get stored. May be NULL."]
    #[doc = " \\param error_message Pointer to a string pointer where an error message may get stored. May be NULL."]
    #[doc = " \\param ctls A map of initial ctl values. See openmpt_module_get_ctls()"]
    #[doc = " \\return A pointer to the constructed openmpt_module, or NULL on failure."]
    #[doc = " \\remarks The input data can be discarded after an openmpt_module has been constructed successfully."]
    #[doc = " \\sa openmpt_stream_callbacks"]
    #[doc = " \\sa \\ref libopenmpt_c_fileio"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_create2(
        stream_callbacks: openmpt_stream_callbacks,
        stream: *mut ::std::os::raw::c_void,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        errfunc: openmpt_error_func,
        erruser: *mut ::std::os::raw::c_void,
        error: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
        ctls: *const openmpt_module_initial_ctl,
    ) -> *mut openmpt_module;
}
extern "C" {
    #[doc = " \\brief Construct an openmpt_module"]
    #[doc = ""]
    #[doc = " \\param filedata Data to load the module from."]
    #[doc = " \\param filesize Amount of data available."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. The logging function may be called throughout the lifetime of openmpt_module."]
    #[doc = " \\param loguser User-defined data associated with this module. This value will be passed to the logging callback function (logfunc)"]
    #[doc = " \\param ctls A map of initial ctl values. See openmpt_module_get_ctls()"]
    #[doc = " \\return A pointer to the constructed openmpt_module, or NULL on failure."]
    #[doc = " \\remarks The input data can be discarded after an openmpt_module has been constructed successfully."]
    #[doc = " \\sa \\ref libopenmpt_c_fileio"]
    #[doc = " \\deprecated Please use openmpt_module_create_from_memory2()."]
    pub fn openmpt_module_create_from_memory(
        filedata: *const ::std::os::raw::c_void,
        filesize: usize,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        ctls: *const openmpt_module_initial_ctl,
    ) -> *mut openmpt_module;
}
extern "C" {
    #[doc = " \\brief Construct an openmpt_module"]
    #[doc = ""]
    #[doc = " \\param filedata Data to load the module from."]
    #[doc = " \\param filesize Amount of data available."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. The logging function may be called throughout the lifetime of openmpt_module."]
    #[doc = " \\param loguser User-defined data associated with this module. This value will be passed to the logging callback function (logfunc)"]
    #[doc = " \\param errfunc Error function to define error behaviour. May be NULL."]
    #[doc = " \\param erruser Error function user context. Used to pass any user-defined data associated with this module to the logging function."]
    #[doc = " \\param error Pointer to an integer where an error may get stored. May be NULL."]
    #[doc = " \\param error_message Pointer to a string pointer where an error message may get stored. May be NULL."]
    #[doc = " \\param ctls A map of initial ctl values. See openmpt_module_get_ctls()"]
    #[doc = " \\return A pointer to the constructed openmpt_module, or NULL on failure."]
    #[doc = " \\remarks The input data can be discarded after an openmpt_module has been constructed successfully."]
    #[doc = " \\sa \\ref libopenmpt_c_fileio"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_create_from_memory2(
        filedata: *const ::std::os::raw::c_void,
        filesize: usize,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
        errfunc: openmpt_error_func,
        erruser: *mut ::std::os::raw::c_void,
        error: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
        ctls: *const openmpt_module_initial_ctl,
    ) -> *mut openmpt_module;
}
extern "C" {
    #[doc = " \\brief Unload a previously created openmpt_module from memory."]
    #[doc = ""]
    #[doc = " \\param mod The module to unload."]
    pub fn openmpt_module_destroy(mod_: *mut openmpt_module);
}
extern "C" {
    #[doc = " \\brief Set logging function."]
    #[doc = ""]
    #[doc = " Set the logging function of an already constructed openmpt_module."]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param logfunc Logging function where warning and errors are written. The logging function may be called throughout the lifetime of openmpt_module."]
    #[doc = " \\param loguser User-defined data associated with this module. This value will be passed to the logging callback function (logfunc)"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_set_log_func(
        mod_: *mut openmpt_module,
        logfunc: openmpt_log_func,
        loguser: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Set error function."]
    #[doc = ""]
    #[doc = " Set the error function of an already constructed openmpt_module."]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param errfunc Error function to define error behaviour. May be NULL."]
    #[doc = " \\param erruser Error function user context."]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_set_error_func(
        mod_: *mut openmpt_module,
        errfunc: openmpt_error_func,
        erruser: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Get last error."]
    #[doc = ""]
    #[doc = " Return the error currently stored in an openmpt_module. The stored error is not cleared."]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The error currently stored."]
    #[doc = " \\sa openmpt_module_error_get_last_message"]
    #[doc = " \\sa openmpt_module_error_set_last"]
    #[doc = " \\sa openmpt_module_error_clear"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_error_get_last(mod_: *mut openmpt_module) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get last error message."]
    #[doc = ""]
    #[doc = " Return the error message currently stored in an openmpt_module. The stored error is not cleared."]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The error message currently stored."]
    #[doc = " \\sa openmpt_module_error_set_last"]
    #[doc = " \\sa openmpt_module_error_clear"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_error_get_last_message(
        mod_: *mut openmpt_module,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Set last error."]
    #[doc = ""]
    #[doc = " Set the error currently stored in an openmpt_module."]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param error Error to be stored."]
    #[doc = " \\sa openmpt_module_error_get_last"]
    #[doc = " \\sa openmpt_module_error_clear"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_error_set_last(mod_: *mut openmpt_module, error: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Clear last error."]
    #[doc = ""]
    #[doc = " Set the error currently stored in an openmpt_module to OPPENMPT_ERROR_OK."]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\sa openmpt_module_error_get_last"]
    #[doc = " \\sa openmpt_module_error_set_last"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_error_clear(mod_: *mut openmpt_module);
}
extern "C" {
    #[doc = " \\brief Select a sub-song from a multi-song module"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param subsong Index of the sub-song. -1 plays all sub-songs consecutively."]
    #[doc = " \\return 1 on success, 0 on failure."]
    #[doc = " \\sa openmpt_module_get_num_subsongs, openmpt_module_get_selected_subsong, openmpt_module_get_subsong_name"]
    #[doc = " \\remarks Whether subsong -1 (all subsongs consecutively), subsong 0 or some other subsong is selected by default, is an implementation detail and subject to change. If you do not want to care about subsongs, it is recommended to just not call openmpt_module_select_subsong() at all."]
    pub fn openmpt_module_select_subsong(
        mod_: *mut openmpt_module,
        subsong: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get currently selected sub-song from a multi-song module"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return Currently selected sub-song. -1 for all subsongs consecutively, 0 or greater for the current sub-song index."]
    #[doc = " \\sa openmpt_module_get_num_subsongs, openmpt_module_select_subsong, openmpt_module_get_subsong_name"]
    #[doc = " \\since 0.3.0"]
    pub fn openmpt_module_get_selected_subsong(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Set Repeat Count"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param repeat_count Repeat Count"]
    #[doc = "   - -1: repeat forever"]
    #[doc = "   - 0: play once, repeat zero times (the default)"]
    #[doc = "   - n>0: play once and repeat n times after that"]
    #[doc = " \\return 1 on success, 0 on failure."]
    #[doc = " \\sa openmpt_module_get_repeat_count"]
    pub fn openmpt_module_set_repeat_count(
        mod_: *mut openmpt_module,
        repeat_count: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get Repeat Count"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return Repeat Count"]
    #[doc = "   - -1: repeat forever"]
    #[doc = "   - 0: play once, repeat zero times (the default)"]
    #[doc = "   - n>0: play once and repeat n times after that"]
    #[doc = " \\sa openmpt_module_set_repeat_count"]
    pub fn openmpt_module_get_repeat_count(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief approximate song duration"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return Approximate duration of current sub-song in seconds."]
    #[doc = " \\remarks The function may return infinity if the pattern data is too complex to evaluate."]
    pub fn openmpt_module_get_duration_seconds(mod_: *mut openmpt_module) -> f64;
}
extern "C" {
    #[doc = " \\brief Set approximate current song position"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param seconds Seconds to seek to. If seconds is out of range, the position gets set to song start or end respectively."]
    #[doc = " \\return Approximate new song position in seconds."]
    #[doc = " \\sa openmpt_module_get_position_seconds"]
    pub fn openmpt_module_set_position_seconds(mod_: *mut openmpt_module, seconds: f64) -> f64;
}
extern "C" {
    #[doc = " \\brief Get current song position"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return Current song position in seconds."]
    #[doc = " \\sa openmpt_module_set_position_seconds"]
    pub fn openmpt_module_get_position_seconds(mod_: *mut openmpt_module) -> f64;
}
extern "C" {
    #[doc = " \\brief Set approximate current song position"]
    #[doc = ""]
    #[doc = " If order or row are out of range, to position is not modified and the current position is returned."]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param order Pattern order number to seek to."]
    #[doc = " \\param row Pattern row number to seek to."]
    #[doc = " \\return Approximate new song position in seconds."]
    #[doc = " \\sa openmpt_module_set_position_seconds"]
    #[doc = " \\sa openmpt_module_get_position_seconds"]
    pub fn openmpt_module_set_position_order_row(
        mod_: *mut openmpt_module,
        order: i32,
        row: i32,
    ) -> f64;
}
extern "C" {
    #[doc = " \\brief Get render parameter"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param param Parameter to query. See \\ref openmpt_module_render_param"]
    #[doc = " \\param value Pointer to the variable that receives the current value of the parameter."]
    #[doc = " \\return 1 on success, 0 on failure (invalid param or value is NULL)."]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_MASTERGAIN_MILLIBEL"]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_STEREOSEPARATION_PERCENT"]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_INTERPOLATIONFILTER_LENGTH"]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_VOLUMERAMPING_STRENGTH"]
    #[doc = " \\sa openmpt_module_set_render_param"]
    pub fn openmpt_module_get_render_param(
        mod_: *mut openmpt_module,
        param: ::std::os::raw::c_int,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set render parameter"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param param Parameter to set. See \\ref openmpt_module_render_param"]
    #[doc = " \\param value The value to set param to."]
    #[doc = " \\return 1 on success, 0 on failure (invalid param)."]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_MASTERGAIN_MILLIBEL"]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_STEREOSEPARATION_PERCENT"]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_INTERPOLATIONFILTER_LENGTH"]
    #[doc = " \\sa OPENMPT_MODULE_RENDER_VOLUMERAMPING_STRENGTH"]
    #[doc = " \\sa openmpt_module_get_render_param"]
    pub fn openmpt_module_set_render_param(
        mod_: *mut openmpt_module,
        param: ::std::os::raw::c_int,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param mono Pointer to a buffer of at least count elements that receives the mono/center output."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks It is recommended to use the floating point API because of the greater dynamic range and no implied clipping."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_mono(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        mono: *mut i16,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param left Pointer to a buffer of at least count elements that receives the left output."]
    #[doc = " \\param right Pointer to a buffer of at least count elements that receives the right output."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks It is recommended to use the floating point API because of the greater dynamic range and no implied clipping."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_stereo(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        left: *mut i16,
        right: *mut i16,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param left Pointer to a buffer of at least count elements that receives the left output."]
    #[doc = " \\param right Pointer to a buffer of at least count elements that receives the right output."]
    #[doc = " \\param rear_left Pointer to a buffer of at least count elements that receives the rear left output."]
    #[doc = " \\param rear_right Pointer to a buffer of at least count elements that receives the rear right output."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks It is recommended to use the floating point API because of the greater dynamic range and no implied clipping."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_quad(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        left: *mut i16,
        right: *mut i16,
        rear_left: *mut i16,
        rear_right: *mut i16,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param mono Pointer to a buffer of at least count elements that receives the mono/center output."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks Floating point samples are in the [-1.0..1.0] nominal range. They are not clipped to that range though and thus might overshoot."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_float_mono(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        mono: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param left Pointer to a buffer of at least count elements that receives the left output."]
    #[doc = " \\param right Pointer to a buffer of at least count elements that receives the right output."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks Floating point samples are in the [-1.0..1.0] nominal range. They are not clipped to that range though and thus might overshoot."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_float_stereo(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        left: *mut f32,
        right: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param left Pointer to a buffer of at least count elements that receives the left output."]
    #[doc = " \\param right Pointer to a buffer of at least count elements that receives the right output."]
    #[doc = " \\param rear_left Pointer to a buffer of at least count elements that receives the rear left output."]
    #[doc = " \\param rear_right Pointer to a buffer of at least count elements that receives the rear right output."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks Floating point samples are in the [-1.0..1.0] nominal range. They are not clipped to that range though and thus might overshoot."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_float_quad(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        left: *mut f32,
        right: *mut f32,
        rear_left: *mut f32,
        rear_right: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param interleaved_stereo Pointer to a buffer of at least count*2 elements that receives the interleaved stereo output in the order (L,R)."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks It is recommended to use the floating point API because of the greater dynamic range and no implied clipping."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_interleaved_stereo(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        interleaved_stereo: *mut i16,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param interleaved_quad Pointer to a buffer of at least count*4 elements that receives the interleaved quad surround output in the order (L,R,RL,RR)."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks It is recommended to use the floating point API because of the greater dynamic range and no implied clipping."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_interleaved_quad(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        interleaved_quad: *mut i16,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param interleaved_stereo Pointer to a buffer of at least count*2 elements that receives the interleaved stereo output in the order (L,R)."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks Floating point samples are in the [-1.0..1.0] nominal range. They are not clipped to that range though and thus might overshoot."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_interleaved_float_stereo(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        interleaved_stereo: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Render audio data"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param samplerate Sample rate to render output. Should be in [8000,192000], but this is not enforced."]
    #[doc = " \\param count Number of audio frames to render per channel."]
    #[doc = " \\param interleaved_quad Pointer to a buffer of at least count*4 elements that receives the interleaved quad surround output in the order (L,R,RL,RR)."]
    #[doc = " \\return The number of frames actually rendered."]
    #[doc = " \\retval 0 The end of song has been reached."]
    #[doc = " \\remarks The output buffers are only written to up to the returned number of elements."]
    #[doc = " \\remarks You can freely switch between any of the \"openmpt_module_read*\" variants if you see a need to do so. libopenmpt tries to introduce as little switching annoyances as possible. Normally, you would only use a single one of these functions for rendering a particular module."]
    #[doc = " \\remarks Floating point samples are in the [-1.0..1.0] nominal range. They are not clipped to that range though and thus might overshoot."]
    #[doc = " \\sa \\ref libopenmpt_c_outputformat"]
    pub fn openmpt_module_read_interleaved_float_quad(
        mod_: *mut openmpt_module,
        samplerate: i32,
        count: usize,
        interleaved_quad: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Get the list of supported metadata item keys"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return Metadata item keys supported by openmpt_module_get_metadata, as a semicolon-separated list."]
    #[doc = " \\sa openmpt_module_get_metadata"]
    pub fn openmpt_module_get_metadata_keys(
        mod_: *mut openmpt_module,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get a metadata item value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param key Metadata item key to query. Use openmpt_module_get_metadata_keys to check for available keys."]
    #[doc = "          Possible keys are:"]
    #[doc = "          - type: Module format extension (e.g. it) or another similar identifier for modules formats that typically do not use a file extension"]
    #[doc = "          - type_long: Format name associated with the module format (e.g. Impulse Tracker)"]
    #[doc = "          - originaltype: Module format extension (e.g. it) of the original module in case the actual type is a converted format (e.g. mo3 or gdm)"]
    #[doc = "          - originaltype_long: Format name associated with the module format (e.g. Impulse Tracker) of the original module in case the actual type is a converted format (e.g. mo3 or gdm)"]
    #[doc = "          - container: Container format the module file is embedded in, if any (e.g. umx)"]
    #[doc = "          - container_long: Full container name if the module is embedded in a container (e.g. Unreal Music)"]
    #[doc = "          - tracker: Tracker that was (most likely) used to save the module file, if known"]
    #[doc = "          - artist: Author of the module"]
    #[doc = "          - title: Module title"]
    #[doc = "          - date: Date the module was last saved, in ISO-8601 format."]
    #[doc = "          - message: Song message. If the song message is empty or the module format does not support song messages, a list of instrument and sample names is returned instead."]
    #[doc = "          - message_raw: Song message. If the song message is empty or the module format does not support song messages, an empty string is returned."]
    #[doc = "          - warnings: A list of warnings that were generated while loading the module."]
    #[doc = " \\return The associated value for key."]
    #[doc = " \\sa openmpt_module_get_metadata_keys"]
    pub fn openmpt_module_get_metadata(
        mod_: *mut openmpt_module,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the current estimated beats per minute (BPM)."]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\remarks Many module formats lack time signature metadata. It is common that this estimate is off by a factor of two, but other multipliers are also possible."]
    #[doc = " \\remarks Due to the nature of how module tempo works, the estimate may change slightly after switching libopenmpt's output to a different sample rate."]
    #[doc = " \\return The current estimated BPM."]
    pub fn openmpt_module_get_current_estimated_bpm(mod_: *mut openmpt_module) -> f64;
}
extern "C" {
    #[doc = " \\brief Get the current speed"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The current speed in ticks per row."]
    pub fn openmpt_module_get_current_speed(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the current tempo"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The current tempo in tracker units. The exact meaning of this value depends on the tempo mode being used."]
    pub fn openmpt_module_get_current_tempo(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the current order"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The current order at which the module is being played back."]
    pub fn openmpt_module_get_current_order(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the current pattern"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The current pattern that is being played."]
    pub fn openmpt_module_get_current_pattern(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the current row"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The current row at which the current pattern is being played."]
    pub fn openmpt_module_get_current_row(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the current amount of playing channels."]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The amount of sample channels that are currently being rendered."]
    pub fn openmpt_module_get_current_playing_channels(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get an approximate indication of the channel volume."]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param channel The channel whose volume should be retrieved."]
    #[doc = " \\return The approximate channel volume."]
    #[doc = " \\remarks The returned value is solely based on the note velocity and does not take the actual waveform of the playing sample into account."]
    pub fn openmpt_module_get_current_channel_vu_mono(
        mod_: *mut openmpt_module,
        channel: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " \\brief Get an approximate indication of the channel volume on the front-left speaker."]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param channel The channel whose volume should be retrieved."]
    #[doc = " \\return The approximate channel volume."]
    #[doc = " \\remarks The returned value is solely based on the note velocity and does not take the actual waveform of the playing sample into account."]
    pub fn openmpt_module_get_current_channel_vu_left(
        mod_: *mut openmpt_module,
        channel: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " \\brief Get an approximate indication of the channel volume on the front-right speaker."]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param channel The channel whose volume should be retrieved."]
    #[doc = " \\return The approximate channel volume."]
    #[doc = " \\remarks The returned value is solely based on the note velocity and does not take the actual waveform of the playing sample into account."]
    pub fn openmpt_module_get_current_channel_vu_right(
        mod_: *mut openmpt_module,
        channel: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " \\brief Get an approximate indication of the channel volume on the rear-left speaker."]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param channel The channel whose volume should be retrieved."]
    #[doc = " \\return The approximate channel volume."]
    #[doc = " \\remarks The returned value is solely based on the note velocity and does not take the actual waveform of the playing sample into account."]
    pub fn openmpt_module_get_current_channel_vu_rear_left(
        mod_: *mut openmpt_module,
        channel: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " \\brief Get an approximate indication of the channel volume on the rear-right speaker."]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param channel The channel whose volume should be retrieved."]
    #[doc = " \\return The approximate channel volume."]
    #[doc = " \\remarks The returned value is solely based on the note velocity and does not take the actual waveform of the playing sample into account."]
    pub fn openmpt_module_get_current_channel_vu_rear_right(
        mod_: *mut openmpt_module,
        channel: i32,
    ) -> f32;
}
extern "C" {
    #[doc = " \\brief Get the number of sub-songs"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The number of sub-songs in the module. This includes any \"hidden\" songs (songs that share the same sequence, but start at different order indices) and \"normal\" sub-songs or \"sequences\" (if the format supports them)."]
    #[doc = " \\sa openmpt_module_get_subsong_name, openmpt_module_select_subsong, openmpt_module_get_selected_subsong"]
    pub fn openmpt_module_get_num_subsongs(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the number of pattern channels"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The number of pattern channels in the module. Not all channels do necessarily contain data."]
    #[doc = " \\remarks The number of pattern channels is completely independent of the number of output channels. libopenmpt can render modules in mono, stereo or quad surround, but the choice of which of the three modes to use must not be made based on the return value of this function, which may be any positive integer amount. Only use this function for informational purposes."]
    pub fn openmpt_module_get_num_channels(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the number of orders"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The number of orders in the current sequence of the module."]
    pub fn openmpt_module_get_num_orders(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the number of patterns"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The number of distinct patterns in the module."]
    pub fn openmpt_module_get_num_patterns(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the number of instruments"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The number of instrument slots in the module. Instruments are a layer on top of samples, and are not supported by all module formats."]
    pub fn openmpt_module_get_num_instruments(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the number of samples"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return The number of sample slots in the module."]
    pub fn openmpt_module_get_num_samples(mod_: *mut openmpt_module) -> i32;
}
extern "C" {
    #[doc = " \\brief Get a sub-song name"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param index The sub-song whose name should be retrieved"]
    #[doc = " \\return The sub-song name."]
    #[doc = " \\sa openmpt_module_get_num_subsongs, openmpt_module_select_subsong, openmpt_module_get_selected_subsong"]
    pub fn openmpt_module_get_subsong_name(
        mod_: *mut openmpt_module,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get a channel name"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param index The channel whose name should be retrieved"]
    #[doc = " \\return The channel name."]
    #[doc = " \\sa openmpt_module_get_num_channels"]
    pub fn openmpt_module_get_channel_name(
        mod_: *mut openmpt_module,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get an order name"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param index The order whose name should be retrieved"]
    #[doc = " \\return The order name."]
    #[doc = " \\sa openmpt_module_get_num_orders"]
    pub fn openmpt_module_get_order_name(
        mod_: *mut openmpt_module,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get a pattern name"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param index The pattern whose name should be retrieved"]
    #[doc = " \\return The pattern name."]
    #[doc = " \\sa openmpt_module_get_num_patterns"]
    pub fn openmpt_module_get_pattern_name(
        mod_: *mut openmpt_module,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get an instrument name"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param index The instrument whose name should be retrieved"]
    #[doc = " \\return The instrument name."]
    #[doc = " \\sa openmpt_module_get_num_instruments"]
    pub fn openmpt_module_get_instrument_name(
        mod_: *mut openmpt_module,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get a sample name"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param index The sample whose name should be retrieved"]
    #[doc = " \\return The sample name."]
    #[doc = " \\sa openmpt_module_get_num_samples"]
    pub fn openmpt_module_get_sample_name(
        mod_: *mut openmpt_module,
        index: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get pattern at order position"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param order The order item whose pattern index should be retrieved."]
    #[doc = " \\return The pattern index found at the given order position of the current sequence."]
    pub fn openmpt_module_get_order_pattern(mod_: *mut openmpt_module, order: i32) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the number of rows in a pattern"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param pattern The pattern whose row count should be retrieved."]
    #[doc = " \\return The number of rows in the given pattern. If the pattern does not exist, 0 is returned."]
    pub fn openmpt_module_get_pattern_num_rows(mod_: *mut openmpt_module, pattern: i32) -> i32;
}
extern "C" {
    #[doc = " \\brief Get raw pattern content"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param pattern The pattern whose data should be retrieved."]
    #[doc = " \\param row The row from which the data should be retrieved."]
    #[doc = " \\param channel The channel from which the data should be retrieved."]
    #[doc = " \\param command The cell index at which the data should be retrieved. See \\ref openmpt_module_command_index"]
    #[doc = " \\return The internal, raw pattern data at the given pattern position."]
    pub fn openmpt_module_get_pattern_row_channel_command(
        mod_: *mut openmpt_module,
        pattern: i32,
        row: i32,
        channel: i32,
        command: ::std::os::raw::c_int,
    ) -> u8;
}
extern "C" {
    #[doc = " \\brief Get formatted (human-readable) pattern content"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param pattern The pattern whose data should be retrieved."]
    #[doc = " \\param row The row from which the data should be retrieved."]
    #[doc = " \\param channel The channel from which the data should be retrieved."]
    #[doc = " \\param command The cell index at which the data should be retrieved."]
    #[doc = " \\return The formatted pattern data at the given pattern position. See \\ref openmpt_module_command_index"]
    #[doc = " \\sa openmpt_module_highlight_pattern_row_channel_command"]
    pub fn openmpt_module_format_pattern_row_channel_command(
        mod_: *mut openmpt_module,
        pattern: i32,
        row: i32,
        channel: i32,
        command: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get highlighting information for formatted pattern content"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param pattern The pattern whose data should be retrieved."]
    #[doc = " \\param row The row from which the data should be retrieved."]
    #[doc = " \\param channel The channel from which the data should be retrieved."]
    #[doc = " \\param command The cell index at which the data should be retrieved. See \\ref openmpt_module_command_index"]
    #[doc = " \\return The highlighting string for the formatted pattern data as retrieved by openmpt_module_get_pattern_row_channel_command at the given pattern position."]
    #[doc = " \\remarks The returned string will map each character position of the string returned by openmpt_module_get_pattern_row_channel_command to a highlighting instruction."]
    #[doc = "          Possible highlighting characters are:"]
    #[doc = "          - \" \" : empty/space"]
    #[doc = "          - \".\" : empty/dot"]
    #[doc = "          - \"n\" : generic note"]
    #[doc = "          - \"m\" : special note"]
    #[doc = "          - \"i\" : generic instrument"]
    #[doc = "          - \"u\" : generic volume column effect"]
    #[doc = "          - \"v\" : generic volume column parameter"]
    #[doc = "          - \"e\" : generic effect column effect"]
    #[doc = "          - \"f\" : generic effect column parameter"]
    #[doc = " \\sa openmpt_module_get_pattern_row_channel_command"]
    pub fn openmpt_module_highlight_pattern_row_channel_command(
        mod_: *mut openmpt_module,
        pattern: i32,
        row: i32,
        channel: i32,
        command: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get formatted (human-readable) pattern content"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param pattern The pattern whose data should be retrieved."]
    #[doc = " \\param row The row from which the data should be retrieved."]
    #[doc = " \\param channel The channel from which the data should be retrieved."]
    #[doc = " \\param width The maximum number of characters the string should contain. 0 means no limit."]
    #[doc = " \\param pad If true, the string will be resized to the exact length provided in the width parameter."]
    #[doc = " \\return The formatted pattern data at the given pattern position."]
    #[doc = " \\sa openmpt_module_highlight_pattern_row_channel"]
    pub fn openmpt_module_format_pattern_row_channel(
        mod_: *mut openmpt_module,
        pattern: i32,
        row: i32,
        channel: i32,
        width: usize,
        pad: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get highlighting information for formatted pattern content"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param pattern The pattern whose data should be retrieved."]
    #[doc = " \\param row The row from which the data should be retrieved."]
    #[doc = " \\param channel The channel from which the data should be retrieved."]
    #[doc = " \\param width The maximum number of characters the string should contain. 0 means no limit."]
    #[doc = " \\param pad If true, the string will be resized to the exact length provided in the width parameter."]
    #[doc = " \\return The highlighting string for the formatted pattern data as retrieved by openmpt_module_format_pattern_row_channel at the given pattern position."]
    #[doc = " \\sa openmpt_module_format_pattern_row_channel"]
    pub fn openmpt_module_highlight_pattern_row_channel(
        mod_: *mut openmpt_module,
        pattern: i32,
        row: i32,
        channel: i32,
        width: usize,
        pad: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Retrieve supported ctl keys"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\return A semicolon-separated list containing all supported ctl keys."]
    #[doc = " \\remarks Currently supported ctl values are:"]
    #[doc = "          - load.skip_samples (boolean): Set to \"1\" to avoid loading samples into memory"]
    #[doc = "          - load.skip_patterns (boolean): Set to \"1\" to avoid loading patterns into memory"]
    #[doc = "          - load.skip_plugins (boolean): Set to \"1\" to avoid loading plugins"]
    #[doc = "          - load.skip_subsongs_init (boolean): Set to \"1\" to avoid pre-initializing sub-songs. Skipping results in faster module loading but slower seeking."]
    #[doc = "          - seek.sync_samples (boolean): Set to \"1\" to sync sample playback when using openmpt_module_set_position_seconds or openmpt_module_set_position_order_row."]
    #[doc = "          - subsong (integer): The current subsong. Setting it has identical semantics as openmpt_module_select_subsong(), getting it returns the currently selected subsong."]
    #[doc = "          - play.at_end (text): Chooses the behaviour when the end of song is reached:"]
    #[doc = "                         - \"fadeout\": Fades the module out for a short while. Subsequent reads after the fadeout will return 0 rendered frames."]
    #[doc = "                         - \"continue\": Returns 0 rendered frames when the song end is reached. Subsequent reads will continue playing from the song start or loop start."]
    #[doc = "                         - \"stop\": Returns 0 rendered frames when the song end is reached. Subsequent reads will return 0 rendered frames."]
    #[doc = "          - play.tempo_factor (floatingpoint): Set a floating point tempo factor. \"1.0\" is the default tempo."]
    #[doc = "          - play.pitch_factor (floatingpoint): Set a floating point pitch factor. \"1.0\" is the default pitch."]
    #[doc = "          - render.resampler.emulate_amiga (boolean): Set to \"1\" to enable the Amiga resampler for Amiga modules. This emulates the sound characteristics of the Paula chip and overrides the selected interpolation filter. Non-Amiga module formats are not affected by this setting."]
    #[doc = "          - render.resampler.emulate_amiga_type (string): Configures the filter type to use for the Amiga resampler. Supported values are:"]
    #[doc = "                    - \"auto\": Filter type is chosen by the library and might change. This is the default."]
    #[doc = "                    - \"a500\": Amiga A500 filter."]
    #[doc = "                    - \"a1200\": Amiga A1200 filter."]
    #[doc = "                    - \"unfiltered\": BLEP synthesis without model-specific filters. The LED filter is ignored by this setting. This filter mode is considered to be experimental and might change in the future."]
    #[doc = "          - render.opl.volume_factor (floatingpoint): Set volume factor applied to synthesized OPL sounds, relative to the default OPL volume."]
    #[doc = "          - dither (integer): Set the dither algorithm that is used for the 16 bit versions of openmpt_module_read. Supported values are:"]
    #[doc = "                    - 0: No dithering."]
    #[doc = "                    - 1: Default mode. Chosen by OpenMPT code, might change."]
    #[doc = "                    - 2: Rectangular, 0.5 bit depth, no noise shaping (original ModPlug Tracker)."]
    #[doc = "                    - 3: Rectangular, 1 bit depth, simple 1st order noise shaping"]
    pub fn openmpt_module_get_ctls(mod_: *mut openmpt_module) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get current ctl value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be retrieved."]
    #[doc = " \\return The associated ctl value, or NULL on failure."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\deprecated Please use openmpt_module_ctl_get_boolean(), openmpt_module_ctl_get_integer(), openmpt_module_ctl_get_floatingpoint(), or openmpt_module_ctl_get_text()."]
    pub fn openmpt_module_ctl_get(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Get current ctl boolean value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be retrieved."]
    #[doc = " \\return The associated ctl value, or NULL on failure."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_get_boolean(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get current ctl integer value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be retrieved."]
    #[doc = " \\return The associated ctl value, or NULL on failure."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_get_integer(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
    ) -> i64;
}
extern "C" {
    #[doc = " \\brief Get current ctl floatingpoint value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be retrieved."]
    #[doc = " \\return The associated ctl value, or NULL on failure."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_get_floatingpoint(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " \\brief Get current ctl string value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be retrieved."]
    #[doc = " \\return The associated ctl value, or NULL on failure."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_get_text(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Set ctl value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be set."]
    #[doc = " \\param value The value that should be set."]
    #[doc = " \\return 1 if successful, 0 in case the value is not sensible (e.g. negative tempo factor) or the ctl is not recognized."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\deprecated Please use openmpt_module_ctl_set_boolean(), openmpt_module_ctl_set_integer(), openmpt_module_ctl_set_floatingpoint(), or openmpt_module_ctl_set_text()."]
    pub fn openmpt_module_ctl_set(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set ctl boolean value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be set."]
    #[doc = " \\param value The value that should be set."]
    #[doc = " \\return 1 if successful, 0 in case the value is not sensible (e.g. negative tempo factor) or the ctl is not recognized."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_set_boolean(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set ctl integer value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be set."]
    #[doc = " \\param value The value that should be set."]
    #[doc = " \\return 1 if successful, 0 in case the value is not sensible (e.g. negative tempo factor) or the ctl is not recognized."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_set_integer(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set ctl floatingpoint value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be set."]
    #[doc = " \\param value The value that should be set."]
    #[doc = " \\return 1 if successful, 0 in case the value is not sensible (e.g. negative tempo factor) or the ctl is not recognized."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_set_floatingpoint(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set ctl string value"]
    #[doc = ""]
    #[doc = " \\param mod The module handle to work on."]
    #[doc = " \\param ctl The ctl key whose value should be set."]
    #[doc = " \\param value The value that should be set."]
    #[doc = " \\return 1 if successful, 0 in case the value is not sensible (e.g. negative tempo factor) or the ctl is not recognized."]
    #[doc = " \\sa openmpt_module_get_ctls"]
    #[doc = " \\since 0.5.0"]
    pub fn openmpt_module_ctl_set_text(
        mod_: *mut openmpt_module,
        ctl: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
